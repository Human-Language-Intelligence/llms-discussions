{% extends 'base.html' %}
{% block content %}
<main class="main-application">
  <div class="debate-section">
    <section class="debate-status">
      <div class="status-info">
        <h2>í† ë¡  ì£¼ì œ: {{ topic }}</h2>
        <div id="room-container" data-room="{{ code }}"></div>
      </div>
      <div class="debate-stats">
        <div class="stat-item">
          <div class="stat-number">12</div>
          <div class="stat-label">ì´ ë°œì–¸</div>
        </div>
        <div class="stat-item">
          <div class="stat-number">8:4</div>
          <div class="stat-label">ì°¬ì„±:ë°˜ëŒ€</div>
        </div>
        <div class="stat-item">
          <div class="stat-number">5m</div>
          <div class="stat-label">ì§„í–‰ì‹œê°„</div>
        </div>
      </div>
    </section>
    <section class="participants-panel"></section>
    <section class="chat-container">
      <div class="chat-header">
        <h2 class="chat-title">ğŸ’¬ ì‹¤ì‹œê°„ í† ë¡ </h2>
        <div class="debate-controls">
          <button class="control-btn active">ğŸ”´ ìŒì„±</button>
          <button class="control-btn secondary">â¸ï¸ ì¼ì‹œì •ì§€</button>
          <button class="control-btn secondary">ğŸ“Š í†µê³„</button>
        </div>
      </div>
      <div class="messages-region" role="log" aria-live="polite">
        <ul class="messages-list" id="messages-list">
        </ul>
      </div>
    </section>
    <section class="input-panel">
      <form class="input-container" onsubmit="sendMessage(event)">
        <textarea id="message-input" class="message-input" placeholder="í† ë¡ ì— ëŒ€í•œ ì˜ê²¬ì„ ë‚˜ëˆ ë³´ì„¸ìš”..." rows="1"></textarea>
        <button type="submit" class="submit-button">ğŸ“¤ ì „ì†¡</button>
      </form>
      <!-- <div class="inputs">
        <input type="text" rows="3" placeholder="Message" name="message" id="message" />
        <button type="button" name="send" id="send-btn" onClick="sendMessage()">Send</button>
        <button type="button" name="live" id="live-btn" onClick="toggleButtonText()">Live</button>
      </div> -->
    </section>
  </div>
  <aside class="history-section">
    <header class="panel-header">
      <h2 class="panel-title">ğŸ“š í† ë¡  íˆìŠ¤í† ë¦¬</h2>
      <p class="panel-description">ì§€ë‚œ ëŒ€í™” ìš”ì•½</p>
    </header>
    <div class="history-region">
      <ul class="history-list" id="history-list"">
      </ul>
    </div>
    <div class=" panel-navigation">
        <a href="{{ url_for('home') }}" class="home-link">ğŸ  ìƒˆë¡œìš´ í† ë¡  ì‹œì‘</a>
    </div>
  </aside>
</main>

<script type="module">
  import { createProfileBlock, getUserClass, getRoleLabel } from '../static/js/utils.js';

  function simulateTypingRemoval(element, delay = 100) {
    const messageElement = element.querySelector(".bubble p");
    if (!messageElement) return;

    const words = messageElement.innerText.split(" ");
    let i = words.length;

    const removeWord = () => {
      if (i >= 0) {
        messageElement.innerText = words.slice(0, i).join(" ");
        i--;
        setTimeout(removeWord, delay);
      }
    };

    removeWord();
  }

  function scrollDownAndHideAlert() {
    setTimeout(() => {
      const messageContainer = document.getElementById("messages-list");
      if (!messageContainer) return;

      const lastMessage = messageContainer.lastElementChild;
      if (lastMessage) {
        lastMessage.scrollIntoView({ behavior: "smooth", block: "end" });
      } else {
        messageContainer.scrollTop = messageContainer.scrollHeight;
      }

      toggleNewMessageAlert(false);
    }, 50);
  }

  function toggleNewMessageAlert(show = true) {
    const alertBox = document.getElementById("new-message-alert");
    if (!alertBox) return;

    alertBox.classList.toggle("hidden", !show);
  }

  // function toggleButtonText() {
  //   var button = document.getElementById("live-btn");
  //   if (button.innerHTML === "Live") {
  //     button.innerHTML = "UnLive";
  //     button.classList.remove("live");
  //     button.classList.add("unlive");
  //     isLive = false;
  //     socket.emit("live", { status: "UnLive" });
  //   } else {
  //     button.innerHTML = "Live";
  //     button.classList.remove("unlive");
  //     button.classList.add("live");
  //     isLive = true;
  //     socket.emit("live", { status: "Live" });
  //   }
  // }

  document.addEventListener("DOMContentLoaded", () => {
    const roomCode = document.getElementById("room-container").getAttribute("data-room");
    const messageContainer = document.getElementById("messages-list");
    const historyContainer = document.getElementById("history-list");
    const messageInput = document.getElementById("message");
    // const alertBox = document.getElementById("new-message-alert");

    let user1Role = "pros";
    let isUserNearBottom = true;
    let isLive = true; // default to live

    const isNearBottom = () => {
      const threshold = 500;
      const distanceFromBottom = messageContainer.scrollHeight - messageContainer.scrollTop - messageContainer.clientHeight;
      return distanceFromBottom < threshold;
    };

    const scrollDown = () => {
      if (isNearBottom()) {
        messageContainer.scrollTo({
          top: messageContainer.scrollHeight,
          behavior: 'smooth'
        });
      }
    };

    const clearMessages = () => {
      messageContainer.innerHTML = '';
    };

    const sendMessage = () => {
      if (message.value.trim() !== "") {
        socket.emit("user", { data: messageInput.value });
        if (!isLive) {
          socket.emit("typing", { is_typing: false, message: "" });
        }
        messageInput.value = "";
      }
    };

    const showTyping = (name, role, typingText) => {
      const isUser1 = role === user1Role;
      const textAlignStyle = isUser1 ? "flex-end" : "flex-start";
      const userClass = getUserClass(role, user1Role);
      const sideLabel = getRoleLabel(role);

      if (typingText === "") {
        const existingTypingMessage = document.querySelector(
          `.${userClass}.${role}-typing-message`
        );
        if (existingTypingMessage) {
          existingTypingMessage.remove();
        }
        return;
      }

      const formattedTyping = typingText.replace(/\n/g, "<br>");
      const typingContent = `
      <div class="message typing-message ${userClass} ${role}-typing-message">
        <div class="bubble" style="align-self: ${textAlignStyle};">
          ${createProfileBlock(name, role)}
          <p>${formattedTyping}</p>
        </div>
        <span class="timestamp">${name} is typing ...</span>
      </div>
      `;

      const existingTypingMessage = document.querySelector(`.${userClass}.${role}-typing-message`);

      if (!existingTypingMessage) {
        messageContainer.insertAdjacentHTML("beforeend", typingContent);
      } else {
        existingTypingMessage.innerHTML = typingContent;
      }

      scrollDown();
    };

    const createChatMessage = ({
      name,
      message,
      timestamp = new Date().toLocaleString(),
      role = "user" // "user", "admin", "pros", "cons"
    }) => {
      const userClass = getUserClass(role, user1Role);
      const profileBlock = createProfileBlock(name, role);
      const formattedMessage = message.replace(/\n/g, "<br>");

      const content = `
      <li class="message-item" data-role="${role}">
        <div class="message-content">
          ${profileBlock}
          <div class="message-bubble">
            <p class="message-text">${formattedMessage}</p>
          </div>
          <time class="message-timestamp">${timestamp}</time>
        </div>
      </li>`;
      messageContainer.insertAdjacentHTML("beforeend", content);

      if (isUserNearBottom) {
        scrollDown();
      } else {
        toggleNewMessageAlert(true);
      }
    };

    const appendToHistory = ({
      data,
      timestamp = new Date().toLocaleString()
    }) => {
      const userClass = getUserClass(data.role, user1Role);
      const profileBlock = createProfileBlock(data.name, data.role);
      const formattedMessage = data.message.replace(/\n/g, "<br>");

      const content = `
      <li class="history-item" data-role="${data.role}">
        <div class="history-meta">
          ${profileBlock}
        </div>
        <p class="history-message">${formattedMessage}</p>
        <time class="message-timestamp">${data.timestamp}</time>
      </li>
      `;

      historyContainer.insertAdjacentHTML("afterbegin", content);
    };

    const handleTypingMessage = (role, isUser1 = false, simulateRemoval = false) => {
      const userClass = isUser1 ? "user1" : "user2";
      const typingSelector = `.${userClass}.${role}-typing-message, .${role}-typing-message`;

      const existingTypingMessage = document.querySelector(typingSelector);
      if (existingTypingMessage) {
        if (simulateRemoval) {
          simulateTypingRemoval(existingTypingMessage);
        } else {
          existingTypingMessage.remove();
        }
      }
    };

    const handleMessage = (data) => {
      const isUser1 = data.role === user1Role;
      const userClass = isUser1 ? "user1" : "user2";

      if (data.is_typing) {
        showTyping(data.name, data.role, data.message);
      } else {
        createChatMessage({
          name: data.name,
          message: data.message,
          role: data.role,
        });

        handleTypingMessage(data.role)

        if (data.audio_base64) {
          playAudio(data);
        }
      }
    };

    const playAudio = (data) => {
      const audio = new Audio("data:audio/ogg;base64," + data.audio_base64);
      audio.play();
      audio.onended = function () {
        appendToHistory({ data: data, timestamp: new Date().toLocaleString() });
        clearMessages();

        socket.emit("complete", { role: data.role, room: roomCode });
        console.log(`Complete: ${data.role}, room: ${roomCode}`);
      };
    };

    // messageInput.addEventListener("input", function () {
    //   const typingText = messageInput.value.trim();
    //   if (isLive) {
    //     socket.emit("typing", {
    //       is_typing: typingText !== "",
    //       message: typingText,
    //     });
    //   }
    // });

    // messageInput.addEventListener("keydown", function (event) {
    //   if (event.key === "Enter") {
    //     event.preventDefault();
    //     sendMessage();
    //   }
    // });

    socket.on("connect", function () {
      var userTopic = "{{ topic }}";
      socket.emit("start", { topic: userTopic });
    });

    socket.on("message", (data) => {
      if (data.is_typing) {
        showTyping(data.name, data.role, data.message);
      } else {
        createChatMessage({
          name: data.name,
          message: data.message,
          role: "user",
        });
        handleTypingMessage(data.role);
      }
    });

    socket.on("pros-message", (data) => handleMessage(data));
    socket.on("cons-message", (data) => handleMessage(data));

    socket.on("clear-pros-response", () => handleTypingMessage("pros", false, true));
    socket.on("clear-cons-response", () => handleTypingMessage("cons", false, true));

    console.log("room code:", roomCode);
  });

</script>
{% endblock %}

{% extends 'base.html' %}
{% block content %}
<main class="main-application">
  <div class="debate-section">
    <section class="debate-status">
      <div class="status-info">
        <h2>토론 주제: {{ topic }}</h2>
        <div id="room-container" data-room="{{ code }}" data-topic="{{ topic }}"></div>
      </div>
      <div class="debate-stats">
        <div class="stat-item">
          <div class="stat-number" id="total-messages">0</div>
          <div class="stat-label">총 발언</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="debate-ratio">0:0</div>
          <div class="stat-label">찬성:반대</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="debate-time">0m</div>
          <div class="stat-label">진행시간</div>
        </div>
      </div>
    </section>

    <section class="chat-container">
      <div class="chat-header">
        <h2 class="chat-title">💬 실시간 토론</h2>
        <div class="debate-controls">
          <button class="control-btn active" id="audio-btn">🔴 음성</button>
          <button class="control-btn secondary" id="pause-btn">⏸️ 일시정지</button>
          <button class="control-btn secondary" id="stats-btn">📊 결과 보기</button>
        </div>
      </div>

      <div class="messages-region" role="log" aria-live="polite">
        <div class="active-messages" id="active-messages">
          <!-- 각 role별 현재 메시지 컨테이너 -->
          <div class="role-message-container" id="pros-container" data-role="pros"></div>
          <div class="role-message-container" id="user-container" data-role="user"></div>
          <div class="role-message-container" id="cons-container" data-role="cons"></div>
        </div>
      </div>
    </section>

    <section class="input-panel">
      <form class="input-container" onsubmit="sendMessage(event)">
        <textarea id="message-input" class="message-input input" placeholder="토론에 대한 의견을 나눠보세요..." rows="1"
          maxlength="500"></textarea>
        <button type="submit" class="submit-button btn btn-primary">📤 전송</button>
      </form>
      <div class="input-info">
        <span class="char-count" id="char-count">0/500</span>
        <span class="input-hint">Enter로 전송, Shift+Enter로 줄바꿈</span>
      </div>
    </section>
  </div>

  <aside class="history-section">
    <header class="panel-header">
      <h2 class="panel-title">📚 토론 히스토리</h2>
      <p class="panel-description">지난 대화 요약</p>
      <div class="history-controls">
        <button class="btn btn-secondary" id="export-btn">📁 내보내기</button>
        <button class="btn btn-secondary" id="clear-history-btn">🗑️ 지우기</button>
      </div>
    </header>

    <div class="history-region">
      <ul class="history-list" id="history-list">
        <!-- 히스토리 아이템들이 여기에 동적으로 추가됩니다 -->
      </ul>
      <div class="history-empty" id="history-empty">
        <div class="empty-icon">📝</div>
        <p>아직 대화 기록이 없습니다</p>
      </div>
    </div>

    <div class="panel-navigation">
      <a href="{{ url_for('home') }}" class="home-link btn btn-primary">
        🏠 새로운 토론 시작
      </a>
    </div>
  </aside>

  <!-- 로딩 오버레이 -->
  <div id="eval-overlay" class="eval-overlay hidden" aria-live="polite" aria-busy="true">
    <div class="eval-card">
      <div class="spinner" aria-hidden="true"></div>
      <div class="eval-text">
        <strong>평가를 진행 중입니다…</strong>
        <span>LLM Judge · Coherence · Diversity 계산 중</span>
      </div>
    </div>
  </div>

  <!-- 토스트 -->
  <div id="toast" class="toast hidden" role="status" aria-live="polite"></div>
</main>

<script type="module">
  import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";
  import { createProfileBlock, getUserClass, getRoleLabel, getAvatarPath } from '../static/js/utils.js';

  const socket = io();

  // 전역 변수
  let debateStats = {
    totalMessages: 0,
    prosMessages: 0,
    consMessages: 0,
    startTime: Date.now()
  };

  let currentData = null;
  let audio = null;
  let audioOn = true;

  // 각 role별 현재 메시지 저장
  let currentMessages = {
    pros: null,
    cons: null,
    user: null
  };

  function isAudioPlaying() {
    return audio && !audio.paused && !audio.ended && audio.currentTime > 0;
  }

  // DOM 요소들
  const roomCode = document.getElementById("room-container").getAttribute("data-room");
  const activeMessages = document.getElementById("active-messages");
  const historyContainer = document.getElementById("history-list");
  const messageInput = document.getElementById("message-input");
  const charCount = document.getElementById("char-count");
  const historyEmpty = document.getElementById("history-empty");

  const updateStats = () => {
    document.getElementById("total-messages").textContent = debateStats.totalMessages;
    document.getElementById("debate-ratio").textContent = `${debateStats.prosMessages}:${debateStats.consMessages}`;

    const elapsed = Math.floor((Date.now() - debateStats.startTime) / 60000);
    document.getElementById("debate-time").textContent = `${elapsed}m`;
  };

  const updateHistoryVisibility = () => {
    const hasHistory = historyContainer.children.length > 0;
    historyEmpty.classList.toggle("hidden", hasHistory);
  };

  // role별 메시지 업데이트/생성 함수
  const updateRoleMessage = ({
    name,
    message,
    timestamp = new Date().toLocaleString(),
    role = "user",
    is_typing = false
  }) => {
    const container = document.getElementById(`${role}-container`);
    if (!container) return;

    const roleLabel = getRoleLabel(role);
    const formattedMessage = message.replace(/\n/g, "<br>");

    // 타이핑 중이면 타이핑 인디케이터 추가
    const typingIndicator = is_typing ? `
      <div class="typing-indicator">
        <span></span><span></span><span></span>
      </div>
    ` : '';

    container.innerHTML = `
      <div class="message-item ${is_typing ? 'typing-message' : ''}" data-role="${role}">
        <div class="message-content">
          <div class="message-header">
            <img src="${getAvatarPath(name, role)}" alt="${name}" class="speaker-avatar">
            <div class="speaker-info">
              <h3 class="speaker-name">${name.toUpperCase()}</h3>
              <span class="speaker-role">${roleLabel}</span>
            </div>
          </div>
          <div class="message-bubble ${is_typing ? 'typing-bubble' : ''}">
            <p class="message-text">${formattedMessage}</p>
            ${typingIndicator}
          </div>
          ${!is_typing ? `<time class="message-timestamp">${timestamp}</time>` : ''}
        </div>
      </div>
    `;

    // 메시지가 완료되면 현재 메시지 저장
    if (!is_typing && message) {
      currentMessages[role] = {
        name,
        message,
        timestamp,
        role
      };

      // 통계 업데이트
      debateStats.totalMessages++;
      if (role === 'pros') debateStats.prosMessages++;
      if (role === 'cons') debateStats.consMessages++;
      updateStats();
    }
  };

  // 히스토리에 추가
  const appendToHistory = ({
    data,
    timestamp = new Date().toLocaleString()
  }) => {
    const roleLabel = getRoleLabel(data.role);
    const formattedMessage = data.message.replace(/\n/g, "<br>");

    const historyElement = document.createElement('li');
    historyElement.className = 'history-item';
    historyElement.setAttribute('data-role', data.role);

    historyElement.innerHTML = `
      <div class="history-meta">
        <img src="${getAvatarPath(data.name, data.role)}" alt="${data.name}" class="speaker-avatar">
        <div class="speaker-info">
          <h3 class="speaker-name">${data.name.toUpperCase()}</h3>
          <span class="speaker-role">${roleLabel}</span>
        </div>
      </div>
      <p class="history-message">${formattedMessage}</p>
      <time class="message-timestamp">${timestamp}</time>
    `;

    historyContainer.insertBefore(historyElement, historyContainer.firstChild);
    updateHistoryVisibility();
  };

  // 메시지 전송
  const sendMessage = (event) => {
    event.preventDefault();
    const message = messageInput.value.trim();

    if (message && socket) {
      socket.emit("user", { data: message });
      messageInput.value = "";
      updateCharCount();
      messageInput.style.height = 'auto';
    }
  };

  // 문자 수 업데이트
  const updateCharCount = () => {
    const count = messageInput.value.length;
    charCount.textContent = `${count}/500`;
    charCount.style.color = count > 400 ? 'var(--error-500)' : 'var(--text-muted)';
  };

  const stopAudio = () => {
    if (audio && isAudioPlaying()) {
      audio.pause();
      audio.currentTime = 0;
    }
  };

  const complete = (data) => {
    appendToHistory({
      data: data,
      timestamp: new Date(data.timestamp).toLocaleString()
    });
    stopAudio();

    if (socket) {
      socket.emit("complete", { role: data.role, room: roomCode });
      console.log(`Complete: ${data.role}, room: ${roomCode}`);
    }
  };

  // 오디오 재생
  const playAudio = (data) => {
    if (!data.audio_base64 || !audioOn) {
      complete(data);
      return;
    }
    const url = "data:audio/ogg;base64," + data.audio_base64;

    audio = new Audio(url);
    audio.onended = () => complete(data);

    stopAudio();
    audio.play().catch(console.error);
  };

  // overlay & toast 유틸
  const overlayEl = document.getElementById("eval-overlay");
  const toastEl = document.getElementById("toast");
  function showOverlay() { overlayEl?.classList.remove("hidden"); }
  function hideOverlay() { overlayEl?.classList.add("hidden"); }
  function showToast(msg, type = "info", timeout = 3000) {
    if (!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.remove("hidden", "error");
    if (type === "error") toastEl.classList.add("error");
    setTimeout(() => toastEl.classList.add("hidden"), timeout);
  }

  // 이벤트 리스너들
  document.addEventListener("DOMContentLoaded", () => {
    // 메시지 입력 이벤트
    messageInput.addEventListener("input", () => {
      updateCharCount();

      // 자동 높이 조절
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
    });

    messageInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        sendMessage(event);
      }
    });

    // 컨트롤 버튼들
    document.getElementById('audio-btn')?.addEventListener('click', (e) => {
      // 오디오 토글 로직
      audioOn = !audioOn;
      e.target.classList.toggle('active', audioOn);

      if (!audioOn) complete(currentData);
    });

    document.getElementById('pause-btn')?.addEventListener('click', (e) => {
      e.target.classList.toggle('active');
      // 일시정지 로직
    });

    document.getElementById('clear-history-btn')?.addEventListener('click', () => {
      if (confirm('히스토리를 모두 삭제하시겠습니까?')) {
        historyContainer.innerHTML = '';
        updateHistoryVisibility();
      }
    });

    document.getElementById('export-btn')?.addEventListener('click', () => {
      // 히스토리 내보내기 로직
      const historyData = Array.from(historyContainer.children).map(item => ({
        role: item.getAttribute('data-role'),
        name: item.querySelector('.speaker-name').textContent,
        message: item.querySelector('.history-message').textContent,
        timestamp: item.querySelector('.message-timestamp').textContent
      }));

      const blob = new Blob([JSON.stringify(historyData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `debate-history-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    // 평과 결과 보기
    document.getElementById('stats-btn')?.addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      const roomCode = document.getElementById("room-container").getAttribute("data-room");
      const topic = document.getElementById("room-container").getAttribute("data-topic");

      // 버튼 중복 클릭 방지 + 오버레이 표시
      btn.disabled = true;
      btn.classList.add('loading'); // 필요하면 CSS에서 스타일링
      btn.textContent = "⏳ 평가 중…";
      showOverlay();

      try {
        const response = await fetch("/evaluate", {
          method: "POST",
          credentials: "same-origin",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ room: roomCode, topic })
        });

        if (!response.ok) {
          const err = await response.json().catch(() => ({}));
          throw new Error(err.error || `HTTP ${response.status}`);
        }

        // 성공 → 결과 페이지로 이동
        window.location.href = "/result";

      } catch (err) {
        console.error("Evaluation error:", err);
        showToast("❌ 통계 평가 중 오류 발생: " + err.message, "error");
        hideOverlay();
        btn.disabled = false;
        btn.classList.remove('loading');
        btn.textContent = "📊 결과 보기";
      }
    });

    updateStats();
    updateHistoryVisibility();
  });

  // Socket.IO 이벤트 핸들러들
  if (typeof socket !== 'undefined') {
    socket.on("connect", function () {
      const userTopic = "{{ topic }}";
      socket.emit("start", { topic: userTopic });
    });

    socket.on("message", (data) => {
      updateRoleMessage({
        name: data.name,
        message: data.message,
        role: "user",
        is_typing: data.is_typing || false
      });

      appendToHistory({
        data: data,
        timestamp: new Date(data.timestamp).toLocaleString()
      });
    });

    socket.on("pros-message", (data) => {
      currentData = data;

      updateRoleMessage({
        name: data.name,
        message: data.message,
        role: data.role,
        is_typing: data.is_typing || false
      });

      if (!data.is_typing && data.audio_base64) {
        playAudio(data);
      }
    });

    socket.on("cons-message", (data) => {
      currentData = data;

      updateRoleMessage({
        name: data.name,
        message: data.message,
        role: data.role,
        is_typing: data.is_typing || false
      });

      if (!data.is_typing && data.audio_base64) {
        playAudio(data);
      }
    });

    socket.on("clear-pros-response", () => {
      const container = document.getElementById('pros-container');
      if (container) container.innerHTML = '';
    });

    socket.on("clear-cons-response", () => {
      const container = document.getElementById('cons-container');
      if (container) container.innerHTML = '';
    });
  }

  // 전역 함수로 노출
  window.sendMessage = sendMessage;

  console.log("Room code:", roomCode);
</script>
{% endblock %}

{% extends 'base.html' %}
{% block content %}
<div class="container">
  <section class="message-box">
    <h2>í† ë¡  ì£¼ì œ: {{ topic }}</h2>
    <div id="room-container" data-room="{{ code }}"></div>
    <div class="messages scrollbar" id="messages">
      {% for msg in messages %}
      <div class="message {{ 'user1' if msg.name == user1Name else 'user2' }}">
        <div class="bubble">
          <span class="name {{ 'user1' if msg.name == user1Name else 'user2' }}">{{ msg.name }}</span>
          <p>{{ msg.message }}</p>
        </div>
        <span class="timestamp">{{ msg.timestamp }}</span>
      </div>
      {% endfor %}
    </div>
    <!-- <div class="inputs">
    <input type="text" rows="3" placeholder="Message" name="message" id="message" />
    <button type="button" name="send" id="send-btn" onClick="sendMessage()">Send</button>
    <button type="button" name="live" id="live-btn" onClick="toggleButtonText()">Live</button>
  </div> -->
    <div id="new-message-alert" class="new-message-alert hidden" onclick="scrollDownAndHideAlert()">
      ğŸ“© ìƒˆ ëŒ€í™” í™•ì¸í•˜ê¸°
    </div>
  </section>
  <section class="home-button-container">
    <a href="{{ url_for('home') }}" class="home-button">ë‹¤ë¥¸ ì£¼ì œë¡œ í† ë¡  ì‹œì‘</a>
  </section>
</div>

<script>
  var socketIO = io();
  var isLive = true; // default to live

  const roomCode = document.getElementById("room-container").getAttribute("data-room");
  console.log("room code:", roomCode);

  const messageBoxes = document.getElementById("messages");
  const user1Name = "Gemini"; //"{{ session['name'] }}";
  const user2Name = "The Other User"; // TODO

  let isUserNearBottom = true;

  // const scrollDown = () => {
  //   messages.scrollTop = messages.scrollHeight;
  // };
  const scrollDown = () => {
    // ì‚¬ìš©ìê°€ ë©”ì‹œì§€ ëª©ë¡ì˜ ì•„ë˜ìª½ì— ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ ìŠ¤í¬ë¡¤ ë‹¤ìš´
    const threshold = 500; // ì‚¬ìš©ìê°€ ì´ ê°’ë³´ë‹¤ ë” ê°€ê¹Œì´ ìˆì„ ë•Œ ìë™ìœ¼ë¡œ ìŠ¤í¬ë¡¤ ë‹¤ìš´
    const positionFromBottom =
      messageBoxes.scrollHeight -
      (messageBoxes.scrollTop + messageBoxes.clientHeight);

    if (positionFromBottom < threshold) {
      messageBoxes.scrollTop = messageBoxes.scrollHeight;
    }
  };

  const sendMessage = () => {
    const message = document.getElementById("message");
    if (message.value.trim() !== "") {
      socketIO.emit("message", { data: message.value });
      if (!isLive) {
        socketIO.emit("typing", { is_typing: false, message: "" });
      }
      message.value = "";
    }
  };

  const createMessage = (name, msg) => {
    const isAdmin = name === "admin";
    const userClass = isAdmin ? "admin" : name === user1Name ? "user1" : "user2";
    let content = "";

    if (userClass === "admin") {
      content = `
      <div class="message ${userClass}">
        <div class="bubble">
          <span class="name">${name}</span>
          <p>${msg}</p>
        </div>
      </div>
      `;
    } else {
      content = `
      <div class="message ${userClass}">
        <div class="bubble">
          <div class="profile">
            <img src="./static/User.png" alt="user" class="logo">
            <span class="name">${name}</span>
          </div>
          <p>${msg}</p>
        </div>
        <span class="timestamp">${new Date().toLocaleString()}</span>
      </div>
      `;
    }
    messageBoxes.insertAdjacentHTML("beforeend", content);

    if (isUserNearBottom) {
      scrollDown();
    } else {
      showNewMessageAlert();
    }
  };

  const createGPTMessage = (chatgptResponse) => {
    let content = "";

    const formattedResponse = chatgptResponse.replace(/\n/g, "<br>");
    content += `
    <div class="message chatgpt-response">
      <div class="bubble">
          <div class="profile">
            <img src="./static/ChatGPT.png" alt="ChatGPT" class="logo">
            <span class="name">ChatGPT - ì°¬ì„± ì¸¡</span>
          </div>
          <p>${formattedResponse}</p>
      </div>
      <span class="timestamp">${new Date().toLocaleString()}</span>
    </div>
    `;
    messageBoxes.insertAdjacentHTML("beforeend", content);

    if (isUserNearBottom) {
      scrollDown();
    } else {
      showNewMessageAlert();
    }
  };

  const createGeminiMessage = (geminiResponse) => {
    let content = "";

    const formattedResponse = geminiResponse.replace(/\n/g, "<br>");
    content += `
    <div class="message gemini-response">
        <div class="bubble">
            <div class="profile">
              <img src="./static/Gemini.png" alt="Gemini" class="logo">
              <span class="name">Gemini - ë°˜ëŒ€ ì¸¡</span>
            </div>
            <p>${formattedResponse}</p>
        </div>
        <span class="timestamp gemini">${new Date().toLocaleString()}</span>
    </div>
    `;
    messageBoxes.insertAdjacentHTML("beforeend", content);

    if (isUserNearBottom) {
      scrollDown();
    } else {
      showNewMessageAlert();
    }
  };

  const showTyping = (name, typingText) => {
    const isUser1 = name === user1Name;
    const userClass = isUser1 ? "user1" : "user2";
    const textAlignStyle = isUser1 ? "flex-end" : "flex-start";

    if (typingText === "") {
      const existingTypingMessage = document.querySelector(
        `.${userClass}.${name}-typing-message`
      );
      if (existingTypingMessage) {
        existingTypingMessage.remove();
      }
      return;
    }

    const sideLabel = name === "ChatGPT" ? "ì°¬ì„±" : "ë°˜ëŒ€";
    const formattedTyping = typingText.replace(/\n/g, "<br>");
    const typingContent = `
    <div class="message typing-message ${userClass} ${name}-typing-message">
      <div class="bubble" style="align-self: ${textAlignStyle};">
        <div class="profile">
          <img src="./static/${name}.png" class="logo">
          <span class="name">${name} - ${sideLabel} ì¸¡</span>
        </div>
        <p>${formattedTyping}</p>
      </div>
      <span class="timestamp"> ${name} is typing ... </span>
    </div>
    `;
    const existingTypingMessage = document.querySelector(
      `.${userClass}.${name}-typing-message`
    );

    if (existingTypingMessage) {
      existingTypingMessage.innerHTML = typingContent;
    } else {
      messageBoxes.insertAdjacentHTML("beforeend", typingContent);
    }

    scrollDown();
  };

  const createNotification = (msg) => {
    const content = `
      <div class="notification">
        <p>${msg}</p>
      </div>
    `;
    messageBoxes.insertAdjacentHTML("beforeend", content);
    messageBoxes.scrollTop = messageBoxes.scrollHeight;
  };

  function showNewMessageAlert() {
    const alertBox = document.getElementById("new-message-alert");
    if (alertBox) alertBox.classList.remove("hidden");
  }

  function hideNewMessageAlert() {
    const alertBox = document.getElementById("new-message-alert");
    if (alertBox) alertBox.classList.add("hidden");
  }

  function scrollDownAndHideAlert() {
    setTimeout(() => {
      const messageBoxes = document.getElementById("messages"); // ë‹¤ì‹œ í•œ ë²ˆ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°
      const lastMessage = messageBoxes?.lastElementChild;

      if (lastMessage) {
        lastMessage.scrollIntoView({ behavior: "smooth", block: "end" });
      } else {
        messageBoxes.scrollTop = messageBoxes.scrollHeight;
      }

      hideNewMessageAlert();
    }, 50); // ì•½ê°„ì˜ delay ì¤˜ì„œ DOM ë Œë” ì™„ë£Œ í›„ ì‘ë™
  }

  function simulateTypingRemoval(element) {
    const messageElement = element.querySelector(".bubble p");
    const typingText = messageElement.innerText;
    const words = typingText.split(" ");
    const wordCount = words.length;

    // Simulate removing words with a slower delay
    const delay = 100; // Adjust the delay to control the speed
    let i = wordCount;

    function removeWord() {
      if (i >= 0) {
        const updatedText = words.slice(0, i).join(" ");
        messageElement.innerText = updatedText;
        i--;
        setTimeout(removeWord, delay);
      }
    }

    removeWord();
  }

  // function toggleButtonText() {
  //   var button = document.getElementById("live-btn");
  //   if (button.innerHTML === "Live") {
  //     button.innerHTML = "UnLive";
  //     button.classList.remove("live");
  //     button.classList.add("unlive");
  //     isLive = false;
  //     socketIO.emit("live-toggle", { status: "UnLive" });
  //   } else {
  //     button.innerHTML = "Live";
  //     button.classList.remove("unlive");
  //     button.classList.add("live");
  //     isLive = true;
  //     socketIO.emit("live-toggle", { status: "Live" });
  //   }
  // }

  document.addEventListener("DOMContentLoaded", () => {
    const alertBox = document.getElementById("new-message-alert");
    if (alertBox) {
      alertBox.addEventListener("click", scrollDownAndHideAlert);
    }
  });

  messageBoxes.addEventListener("scroll", () => {
    const threshold = 100;
    const positionFromBottom =
      messageBoxes.scrollHeight - (messageBoxes.scrollTop + messageBoxes.clientHeight);

    isUserNearBottom = positionFromBottom < threshold;

    if (isUserNearBottom) {
      hideNewMessageAlert();
    }
  });

  messageBoxes.addEventListener("input", function () {
    const typingText = messageBoxes.value.trim();
    if (isLive) {
      socketIO.emit("typing", {
        is_typing: typingText !== "",
        message: typingText,
      });
    }
  });

  messageBoxes.addEventListener("keydown", function (event) {
    if (event.key === "Enter") {
      event.preventDefault();
      sendMessage();
    }
  });

  socketIO.on("connect", function () {
    var userTopic = "{{ topic }}";
    socketIO.emit("send-topic", { topic: userTopic });
  });

  socketIO.on("message", (data) => {
    if (data.is_typing) {
      showTyping(data.name, data.message);
    } else {
      createMessage(data.name, data.message);
      const isUser1 = data.name === user1Name;
      const userClass = isUser1 ? "user1" : "user2";
      const existingTypingMessage = document.querySelector(
        `.${userClass}.${data.name}-typing-message`
      );
      if (existingTypingMessage) {
        existingTypingMessage.remove();
      }
    }
  });

  socketIO.on("gpt-message", (data) => {
    if (data.is_typing) {
      showTyping("ChatGPT", data.message);
    } else {
      createGPTMessage(data.message);
      const isUser1 = data.name === user1Name;
      const userClass = isUser1 ? "user1" : "user2";
      const existingTypingMessage = document.querySelector(
        `.${userClass}.ChatGPT-typing-message`
      );
      if (existingTypingMessage) {
        existingTypingMessage.remove();
      }
      if (data.audio_base64) {
        const audio = new Audio("data:audio/ogg;base64," + data.audio_base64);
        audio.play();
        audio.onended = function () {
          socketIO.emit("tts-finished", { side: "gpt", room: roomCode });
          console.log("room code:", roomCode);
        };
      }
    }
  });

  socketIO.on("gemini-message", (data) => {
    if (data.is_typing) {
      showTyping("Gemini", data.message);
    } else {
      createGeminiMessage(data.message);
      const isUser1 = data.name === user1Name;
      const userClass = isUser1 ? "user1" : "user2";
      const existingTypingMessage = document.querySelector(
        `.${userClass}.Gemini-typing-message`
      );
      if (existingTypingMessage) {
        existingTypingMessage.remove();
      }
      if (data.audio_base64) {
        const audio = new Audio("data:audio/ogg;base64," + data.audio_base64);
        audio.play();
        audio.onended = function () {
          socketIO.emit("tts_finished", { side: "gemini", room: roomCode });
          console.log("room code:", roomCode);
        };

      }
    }
  });

  socketIO.on("clear-gpt-response", () => {
    const existingTypingMessage = document.querySelector(
      ".ChatGPT-typing-message"
    );
    if (existingTypingMessage) {
      simulateTypingRemoval(existingTypingMessage);
    }
  });

  socketIO.on("clear-gemini-response", () => {
    const existingTypingMessage = document.querySelector(
      ".Gemini-typing-message"
    );
    if (existingTypingMessage) {
      simulateTypingRemoval(existingTypingMessage);
    }
  });

  socketIO.on("notification", function (data) {
    const message = data.message;
    createNotification(message);
  });
</script>
{% endblock %}
